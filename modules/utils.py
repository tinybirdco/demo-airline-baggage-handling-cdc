import importlib
import sys
import os
import logging


# Add the parent directory to the path so that we can import the conf module without fuss
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

def setup_logging(print_to_console=True):
    logger = logging.getLogger('airport_data_generator')
    
    if not logger.handlers:  # Check if the logger already has handlers
        logger.setLevel(logging.DEBUG)  # Set log level to DEBUG to capture all logs

        formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')

        # File Handler for logs
        file_handler = logging.FileHandler('data_generator.log')
        file_handler.setFormatter(formatter)
        logger.addHandler(file_handler)

        # If print_to_console is True, add a StreamHandler to print to console
        if print_to_console:
            stream_handler = logging.StreamHandler()
            stream_handler.setFormatter(formatter)
            logger.addHandler(stream_handler)

    return logger


class Config:
    _instance = None

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super(Config, cls).__new__(cls)
            conf_module = importlib.import_module("conf")
            for attr_name in dir(conf_module):
                if not attr_name.startswith("__"):  # Filter out built-in attributes
                    setattr(cls._instance, attr_name, getattr(conf_module, attr_name))
        
        # Set any derived attributes
        cls._instance.TB_BASE_URL = f"https://{cls._instance.TINYBIRD_API_URI}.tinybird.co/v0/"
        cls._instance.CFLT_BASE_URL = "https://api.confluent.cloud/"

        # Set any static values
        cls._instance.SLEEP_WAIT = 1
        cls._instance.TIMEOUT_WAIT = 15

        return cls._instance
    
    def set_kafka_topics(self, table_names):
        if not self.SOURCE_DB:
            raise ValueError("SOURCE_DB must be set before calling set_kafka_topics().")

        topics = {}

        if self.SOURCE_DB == 'PG':
            for table_name in table_names:
                # The Kafka Topic Name is generated by the Debezium connector using a fixed structure.
                # See https://docs.confluent.io/cloud/current/connectors/cc-postgresql-cdc-source-debezium.html
                topics[table_name] = f"{self.PG_DATABASE}.public.{table_name}"
        if self.SOURCE_DB == 'MYSQL':
            for table_name in table_names:
                # The Kafka Topic Name is generated by the Debezium connector using a fixed structure.
                # See https://docs.confluent.io/cloud/current/connectors/cc-mysql-source-cdc-debezium.html
                # Note that the documentation says 'schemaName' but that is actually just the database name in these configurations.
                topics[table_name] = f"{self.MYSQL_DB_NAME}.{self.MYSQL_DB_NAME}.{table_name}"
        
        setattr(self, f"KAFKA_CDC_TOPICS", topics)
    
    def set_include_tables(self, table_names):
        if not self.SOURCE_DB:
            raise ValueError("SOURCE_DB must be set before calling set_include_tables().")

        include_tables = []

        if self.SOURCE_DB == 'PG':
            for table_name in table_names:
                include_tables.append(f"public.{table_name}")
        if self.SOURCE_DB == 'MYSQL':
            for table_name in table_names:
                include_tables.append(f"{self.MYSQL_DB_NAME}.{table_name}")
        
        setattr(self, f"INCLUDE_TABLES", include_tables)

    def set_source_db(self, source_db):
        if source_db not in ['PG', 'MYSQL']:
            raise ValueError("SOURCE_DB must be either 'PG' or 'MYSQL'.")
        setattr(self, f"SOURCE_DB", source_db)

def bool_to_int(row):
    """Converts boolean values in a row to integers."""
    return {k: int(v) if isinstance(v, bool) else v for k, v in row.items()}

def get_all_files_in_directory(directory):
    """
    Fetches a listing of all files in the provided directory, including subdirectories.
    
    Args:
    - directory (str): The relative path of the directory to search.

    Returns:
    - list: A list of file paths.
    """
    files_to_get = []

    # os.walk() generates the file names in a directory tree
    for dirpath, dirnames, filenames in os.walk(directory):
        for filename in filenames:
            files_to_get.append(os.path.join(dirpath, filename))

    return files_to_get